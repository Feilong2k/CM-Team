[
  {
    "task_id": "2-1",
    "title": "A1 – Backend streaming endpoint for Orion replies",
    "status": "pending",
    "workflow_stage": "orion_planning",
    "basic_info": {
      "goal": "Expose a streaming HTTP endpoint (or SSE) for Orion responses.",
      "area": "Streaming",
      "notes": "Must not fake typing; forward real token chunks from LLM adapter. Persist final message to chat_messages."
    },
    "instruction": {
      "tara": {
        "goal": "Define test-first behavior for a streaming chat endpoint that replaces the current one-shot response.",
        "tests": [
          "In backend/src/_test_/api_chat_messages.spec.js (or a new streaming-focused spec), add tests that call the chat API and assert that responses are delivered as a stream (chunked HTTP or SSE) rather than a single JSON payload.",
          "Add a test that verifies that the final, complete response is persisted to the chat_messages table once the stream finishes.",
          "Add tests for error handling: if the adapter or DB fails mid-stream, the client receives a clear error event and the connection is closed cleanly.",
          "Keep tests at HTTP contract level only (no knowledge of internal adapter types), but make expectations clear enough that Devon must implement real streaming, not fake timers."
        ]
      },
      "devon": {
        "goal": "Implement a real streaming endpoint in the backend that forwards adapter chunks and persists the final message.",
        "steps": [
          "Inspect backend/src/routes/chatMessages.js to understand the current POST /api/chat/messages behavior (single JSON response).",
          "Add a new streaming-capable endpoint (e.g., POST /api/chat/messages/stream or upgrade existing route) that uses HTTP chunked encoding or Server-Sent Events.",
          "Extend the chosen LLM adapter (DS_ChatAdapter or GPT41Adapter) to support a streaming API if it does not already, exposing an async iterator or callback-based interface for tokens/chunks.",
          "For each chunk from the adapter, write it to the HTTP response immediately, respecting the format Tara's tests assert (plain text chunks, JSON lines, or SSE events).",
          "Once the stream completes, assemble the full message text and insert it into chat_messages using the existing DatabaseTool or query helper.",
          "Ensure all error cases cause a clear error to be sent to the client and that no silent failures occur anywhere in the streaming path."
        ]
      }
    },
    "reason": "F2-T1-S2: Implement real streaming for Orion chat responses."
  },
  {
    "task_id": "2-1",
    "title": "A2 – Frontend streaming client integration in ChatPanel",
    "status": "pending",
    "workflow_stage": "orion_planning",
    "basic_info": {
      "goal": "Wire ChatPanel to consume streamed Orion responses.",
      "area": "Streaming",
      "notes": "Introduce streaming helper, manage in-flight AI message, and update content as chunks arrive."
    },
    "instruction": {
      "tara": {
        "goal": "Specify how the ChatPanel should behave when Orion replies via a streaming API.",
        "tests": [
          "In a new frontend test file (e.g., frontend/src/__tests__/ChatPanel.streaming.spec.js), mock the streaming client and verify that incoming chunks update the latest AI message incrementally.",
          "Add a test ensuring that while streaming, the UI shows a typing / loading indicator, and that this indicator disappears when the stream finishes.",
          "Add tests verifying that auto-scroll behavior is correct while streaming (depending on the user-scroll rules from C-tasks: if user is at bottom, view follows the stream; if scrolled up, it does not).",
          "Ensure tests verify that final rendered content after the stream matches the full concatenated text, and markdown rendering only happens in a way that matches the UX decisions."
        ]
      },
      "devon": {
        "goal": "Connect ChatPanel.vue to the backend streaming endpoint and manage streamed updates in the message list.",
        "steps": [
          "Create a streaming helper (e.g., frontend/src/utils/streamOrionReply.js) that wraps fetch/SSE/WebSocket for the new streaming endpoint, with callbacks like onChunk, onDone, onError.",
          "In ChatPanel.vue, introduce state for the currently streaming AI message (e.g., a reference to the last AI message object) and update its content on each chunk.",
          "Ensure that while streaming, the message is visible in the list and that scrolling rules are respected (work with the C1/C2 tasks).",
          "After the stream completes, finalize the AI message by ensuring its content is fully set and markdown-rendered, and that there are no duplicate entries when history is later reloaded from the DB.",
          "Keep all network logic in a composable or utility (no direct fetch logic scattered through templates), in line with the existing architecture."
        ]
      }
    },
    "reason": "F2-T1-S2: Show Orion messages progressively as they stream."
  },
  {
    "task_id": "2-1",
    "title": "A3 – Streaming UX polish (typing indicator & scroll)",
    "status": "pending",
    "workflow_stage": "orion_planning",
    "basic_info": {
      "goal": "Improve UX around streaming (typing indicator, smooth scroll).",
      "area": "Streaming",
      "notes": "Show typing indicator while streaming; ensure scroll behavior doesn’t jitter."
    },
    "instruction": {
      "tara": {
        "goal": "Capture behavioral expectations for streaming UX on the frontend.",
        "tests": [
          "Extend ChatPanel tests to assert that a typing indicator appears whenever a streaming response is in progress and disappears once it completes or errors.",
          "Add tests that verify new chunks do not cause jittery scroll jumps when the user has paused auto-scroll (relying on C1/C2 behavior).",
          "Add tests to ensure that when the user is at the bottom, streaming chunks keep the bottom-most content visible without overscrolling.",
          "Cover error scenarios: if streaming fails mid-way, the UI must show a clear error message and remove the typing indicator."
        ]
      },
      "devon": {
        "goal": "Implement visual polish for streaming interactions in ChatPanel.",
        "steps": [
          "Add a dedicated typing / streaming indicator component or inline element in ChatPanel.vue, tied to the streaming state introduced in A2.",
          "Refine scrollToBottom logic and the userWantsAutoScroll state so that smooth scrolling is used when appropriate and disabled when the user has scrolled away.",
          "Ensure that partial message content updates do not trigger excessive reflows or full rerenders; only the relevant message node should be updated.",
          "Verify manually (and via tests) that the combination of streaming + auto-scroll + manual scroll pause works intuitively and with no silent JavaScript errors in the console."
        ]
      }
    },
    "reason": "F2-T1-S2: Finalize streaming user experience."
  },
  {
    "task_id": "2-1",
    "title": "B1 – Define trace event model for Orion interactions",
    "status": "pending",
    "workflow_stage": "orion_planning",
    "basic_info": {
      "goal": "Design a minimal trace schema for app ↔ Orion ↔ tools.",
      "area": "Trace Dashboard",
      "notes": "Cover user messages, LLM calls, tool invocations, and responses."
    },
    "instruction": {
      "overview": "Define a minimal, consistent TraceEvent model and API response shape that describes interactions between the app, Orion, and tools. B1 does not implement storage or HTTP routes; it locks in the contract that B2 (backend logging + API) and B3 (frontend dashboard) will rely on.",
      "technical_details": {
        "trace_event_fields": [
          "id: opaque unique identifier (string or number); must be stable for a stored event.",
          "timestamp: ISO 8601 string in UTC when the event occurred.",
          "projectId: project external id (e.g., 'P1'); required for all events exposed via the API.",
          "source: one of 'user', 'orion', 'tool', 'system'; indicates who/what produced the event.",
          "type: coarse-grained category, e.g. 'user_message', 'orion_response', 'tool_call', 'tool_result', 'llm_call', 'llm_result', 'system_error'.",
          "direction: for transport-like events, one of 'inbound' | 'outbound' | 'internal'; optional for pure internal events.",
          "toolName: optional string for tool-related events (e.g. 'DatabaseTool', 'FileSystemTool').",
          "requestId: optional correlation id tying a sequence of events for a single chat turn or request.",
          "summary: short human-readable description (one line) suitable for list views.",
          "details: structured JSON payload with additional metadata; may include redacted payload snippets.",
          "error: optional object with { message, code? } when the event represents or includes an error.",
          "metadata: optional JSON blob for implementation-specific fields (kept small enough for API responses)."
        ],
        "event_sources": [
          "chatMessages route: emits events for inbound user messages and outbound Orion responses.",
          "OrionAgent: emits events around LLM calls, tool orchestration, and decision points.",
          "DatabaseToolAgentAdapter and FileSystemTool: emit tool_call and tool_result events with sanitized arguments/results.",
          "(Optional for later) streaming layer: emits streaming-specific events such as 'stream_started', 'stream_chunk', 'stream_completed', 'stream_error'."
        ],
        "api_contract_stub": {
          "endpoint": "GET /api/trace/logs",
          "query_params": [
            "projectId (required for now): external project id, e.g. 'P1'.",
            "type (optional): filter by event type, e.g. 'user_message', 'tool_call'.",
            "source (optional): filter by 'user' | 'orion' | 'tool' | 'system'.",
            "limit (optional): positive integer, default 50, max 200.",
            "offset (optional): non-negative integer for pagination."
          ],
          "response_shape_example": {
            "events": "Array of TraceEvent objects in the chosen order (B2 will decide ordering, but B1 must state the field set).",
            "total": "Optional total count if available (or null when not cheaply computable)."
          }
        }
      },
      "acceptance_criteria": [
        "TraceEvent field list is documented in a single place (DEV note or JSDoc) that B2 and B3 can import or reference.",
        "There is a clear mapping from major interaction points (chat route, OrionAgent, tool adapters) to event types and sources.",
        "Tara can write api_trace.spec.js tests that assert response objects include at least the fields defined in TraceEvent (id, timestamp, projectId, source, type, summary, details/metadata).",
        "The proposed design does not require changes to existing layering rules (routes → controllers → services → models); it can be slotted in as a separate service/module in B2.",
        "Sensitive payloads (e.g., raw DB contents, file contents, secrets) are either summarized or redacted in TraceEvent.details so tests can assert on safe shapes without leaking secrets."
      ],
      "edge_cases": [
        "Events representing failures (tool errors, LLM errors, DB failures in trace logging) must still produce a TraceEvent with an error field that Tara can assert on.",
        "Very large payloads (e.g., long prompts, huge tool results) should not be fully exposed in the API; only short summaries or truncated snippets should appear in details.",
        "Events that do not naturally belong to a project (e.g., global system errors) should either be linked to a synthetic projectId (like 'SYSTEM') or explicitly considered out of scope for Feature 2.",
        "Future streaming-specific events must be representable without changing the core TraceEvent shape (e.g., via type + metadata)."
      ],
      "dependencies": [
        "Feature 2 overall architecture (chatMessages route, OrionAgent, tool adapters) as described in existing Feature 2 implementation requirements.",
        "PostgreSQL as the underlying store, but B1 remains DB-agnostic and only defines logical fields, not exact table DDL (B2 will map TraceEvent to tables).",
        "Existing layering rules and module boundaries in backend/src (routes, services, tools)."
      ],
      "decisions_locked": [
        "TraceEvent must include at least: id, timestamp, projectId, source, type, summary, details/metadata, and optional toolName and error.",
        "The primary filter dimension for the API is projectId; all events surfaced by /api/trace/logs must be scoped by project.",
        "No raw secrets or full payloads (e.g., entire SQL queries with params, full file contents, full prompts) should be exposed directly in the trace API; only summaries or redacted forms are allowed.",
        "Ordering and pagination details (e.g., most-recent-first vs oldest-first) are left to B2 to finalize, but B1 assumes a stable, deterministic ordering that Tara can assert on.",
        "The trace system is designed as an additive observability layer and must not change the behavior of existing chat or tool flows when disabled or degraded."
      ],
      "tara": {
        "goal": "Specify the observable behavior and shape of trace events as exposed via the future /api/trace/logs endpoint, so tests in B2 have a clear contract to target.",
        "steps": [
          "Create or extend backend/src/_test_/api_trace.spec.js (file name may be adjusted to match existing conventions).",
          "In that spec, write a top-level description comment summarizing the TraceEvent contract as defined here (fields, filtering, redaction expectations).",
          "Design test cases that call a hypothetical GET /api/trace/logs?projectId=P1 endpoint and assert that each returned event object includes the TraceEvent core fields (id, timestamp, projectId, source, type, summary, details or metadata).",
          "Add a test case that assumes filtering by type and/or source is available (e.g., only 'user_message' events) and verify via expectations on the type/source fields. The test can be written in a pending/skip state until B2 wires the route.",
          "Add a test (or clear TODO) describing how sensitive fields must be handled: e.g., assert that details never contains raw secrets or full payloads, but instead includes short summaries or redacted keys.",
          "Keep tests focused on the HTTP contract and JSON shape, not on internal storage or table schemas; any DB-specific checks belong to B2’s own tests."
        ],
        "tests": [
          "Spec file exists for /api/trace/logs with at least one describe block documenting the TraceEvent contract.",
          "Tests (or TODOs with clear descriptions) cover: basic event shape, filtering behavior, and redaction of sensitive data.",
          "Tests are written in a way that B2 can activate them by simply implementing the route and backing service, without changing the expectations defined here."
        ]
      },
      "devon": {
        "goal": "Define and document a TraceEvent schema and event taxonomy that other tasks (B2, B3) can implement against without further changes to the contract.",
        "steps": [
          "Add a single source of truth for the TraceEvent shape, preferably as a JSDoc-style typedef or comment in a dedicated backend/src/services/trace/TraceEvent.js (or similar) module. This should list each field, its type, and whether it is required or optional.",
          "In that same module or a nearby DEV note, document the canonical event types (user_message, orion_response, tool_call, tool_result, llm_call, llm_result, system_error, etc.) and which layers are expected to emit each type.",
          "Write a short DEV note (e.g., docs/ or backend/DEV_TRACE_EVENT_MODEL.md) describing the lifecycle of a typical trace sequence for one chat turn: user_message → llm_call → tool_call(s) → tool_result(s) → orion_response. Explicitly show how requestId and projectId tie these together.",
          "For each emitting layer (chatMessages route, OrionAgent, DatabaseToolAgentAdapter, FileSystemTool), document in comments which TraceEvent fields they will populate (e.g., toolName, summary patterns, metadata snippets). Do not implement the emission yet; only define expectations.",
          "Ensure the design can be implemented within existing layering rules: routes should not reach directly into DB tables for trace; instead, B2 will introduce a trace service that all emitters can call.",
          "Review the design against B2 and B3 requirements to confirm that no additional fields are needed for the dashboard (e.g., enough data to render a timeline and detail pane without extra queries). If additional fields are required, add them now to TraceEvent rather than later."
        ],
        "notes": [
          "Avoid introducing concrete table or index names here; B2 will handle physical schema. Focus B1 on the logical event model and API contract.",
          "Keep examples generic and free of secrets; when showing example details payloads, use obviously fake values and highlight where redaction would occur.",
          "Align naming (field names, event types) with existing terminology in OrionAgent and DatabaseToolAgentAdapter to reduce mental overhead for future maintainers."
        ]
      }
    },
    "reason": "F2-T1-S2: Foundation for pop-out trace dashboard."
  },
  {
    "task_id": "2-1",
    "title": "B2 – Implement backend trace logging service and API",
    "status": "pending",
    "workflow_stage": "orion_planning",
    "basic_info": {
      "goal": "Capture trace events and expose them via HTTP.",
      "area": "Trace Dashboard",
      "notes": "Add logging in chatMessages route, OrionAgent, and tool adapters; provide paginated /api/trace endpoint."
    },
    "instruction": {
      "tara": {
        "goal": "Lock in the behavior of the trace API endpoints.",
        "prompt_markdown": "# Tara 2-1-8 – Backend trace logging service and API\\n\\nSee docs/implementation_prompts/tara_2-1-8_backend_trace_b2.json for the full RED-stage testing instructions.",
        "tests": [
          "Extend the api_trace.spec.js tests to cover pagination (limit/offset) and ordering (most recent first, or as decided).",
          "Add tests that simulate different kinds of events (user message, Orion LLM call, tool call) and assert that the trace API returns them with clear type and metadata fields.",
          "Verify that invalid query parameters (e.g., negative limit, invalid filter values) produce clear 400 errors.",
          "Add a test that ensures trace logging does not break the main chat flows even if the trace storage layer fails (e.g., DB error)."
        ]
      },
      "devon": {
        "goal": "Implement a trace logging service and expose it via /api/trace/logs.",
        "steps": [
          "Create a dedicated trace service module under backend/src/services or utils (depending on current conventions) that accepts TraceEvent objects and persists them (DB table or in-memory for now, but no silent loss without a log).",
          "Add instrumentation in backend/src/routes/chatMessages.js to emit trace events for incoming user messages and outgoing Orion responses.",
          "Add instrumentation in OrionAgent and DatabaseToolAgentAdapter (and FileSystemTool) to emit tool-related trace events with arguments and sanitized results.",
          "Implement a new route handler (e.g., backend/src/routes/trace.js) that supports GET /api/trace/logs with limit/offset and filters, satisfying Tara’s tests.",
          "Ensure failures in the trace service are logged but do not break the primary chat/DB flows (fail-loudly in trace, but do not silently corrupt chat behavior)."
        ]
      }
    },
    "reason": "F2-T1-S2: Make Orion interactions inspectable."
  },
  {
    "task_id": "2-1",
    "title": "B3 – Frontend pop-out trace dashboard view",
    "status": "pending",
    "workflow_stage": "orion_planning",
    "basic_info": {
      "goal": "Create a dashboard UI to inspect Orion traffic and tool calls.",
      "area": "Trace Dashboard",
      "notes": "New view with timeline + detail pane, accessible from chat UI; polls trace API."
    },
    "instruction": {
      "tara": {
        "goal": "Define what the trace dashboard must show and how it refreshes.",
        "tests": [
          "Create a frontend test file for the dashboard (e.g., frontend/src/__tests__/TraceDashboard.spec.js) that mounts the view with mocked API responses.",
          "Add tests that verify a timeline list is rendered with events in the order returned by the API, showing at least type, timestamp, and a summary/label.",
          "Add tests that when a timeline item is clicked, a detail pane is shown with expanded metadata (payload snippets, tool arguments, etc.).",
          "Add tests that simulate periodic polling or a manual refresh action and assert that new events appear without breaking existing selection state."
        ]
      },
      "devon": {
        "goal": "Build a pop-out (or separate route) dashboard that consumes the trace API.",
        "steps": [
          "Add a new route-level view in frontend/src/views (e.g., TraceDashboard.vue) and a corresponding route entry in frontend/src/router.",
          "Design a two-pane layout: left pane for a scrollable event list, right pane for event details.",
          "Implement a small data layer (in a composable or store) that calls /api/trace/logs with pagination and optional filters (e.g., current project).",
          "Wire up a button from the main UI (near ChatPanel) to open this dashboard (either as a new tab/window or an in-app route).",
          "Ensure the dashboard handles errors gracefully (API failures), showing an inline error rather than crashing the app."
        ]
      }
    },
    "reason": "F2-T1-S2: Visualize Orion pipelines and debugging info."
  },
  {
    "task_id": "2-1",
    "title": "C1 – Detect user scroll state to control auto-scroll",
    "status": "pending",
    "workflow_stage": "orion_planning",
    "basic_info": {
      "goal": "Track whether user is at bottom of chat or has scrolled up.",
      "area": "Chat UX",
      "notes": "Extend handleScroll in ChatPanel to compute isAtBottom and set a userWantsAutoScroll flag."
    },
    "instruction": {
      "tara": {
        "goal": "Specify the observable behavior of auto-scroll vs. manual scroll for ChatPanel.",
        "tests": [
          "In ChatPanel tests, simulate scrolling to the bottom and sending messages; assert that auto-scroll remains enabled and new messages are visible at the bottom.",
          "Simulate the user scrolling up (not at bottom), then send new messages; assert that the scroll position does not jump to the bottom.",
          "Add tests that detect when the user scrolls back to the bottom and verify that auto-scroll is re-enabled for subsequent messages.",
          "Add tests that verify internal flags (like userWantsAutoScroll) are correctly toggled based on scroll actions, via behavior assertions."
        ]
      },
      "devon": {
        "goal": "Implement robust detection of user scroll state in ChatPanel.vue.",
        "steps": [
          "In ChatPanel.vue, extend handleScroll to compute isAtBottom using scrollTop, clientHeight, and scrollHeight, with a small threshold so tiny offsets still count as bottom.",
          "Introduce a reactive flag (e.g., userWantsAutoScroll) that is set to false when the user scrolls up away from the bottom, and true when they return to the bottom.",
          "Refactor the existing watch(messages) so it only calls scrollToBottom() when userWantsAutoScroll is true.",
          "Ensure that this logic also cooperates with streaming updates (from A-tasks) so that partial chunks respect the user’s scroll preference."
        ]
      }
    },
    "reason": "F2-T1-S2: Preconditions for pausing auto-scroll."
  },
  {
    "task_id": "2-1",
    "title": "C2 – Pause/resume auto-scroll when user scrolls",
    "status": "pending",
    "workflow_stage": "orion_planning",
    "basic_info": {
      "goal": "Stop auto-scroll when user scrolls up; resume when they return to bottom.",
      "area": "Chat UX",
      "notes": "Condition the messages watcher on userWantsAutoScroll; add optional \"new messages below\" pill."
    },
    "instruction": {
      "tara": {
        "goal": "Fully specify paused auto-scroll behavior and visible cues.",
        "tests": [
          "Extend ChatPanel tests so that when the user scrolls up and new messages arrive, a \"new messages below\" indicator appears while the scroll position stays fixed.",
          "Add a test that clicking the indicator scrolls to the bottom and clears the indicator.",
          "Verify that once the user is back at the bottom (via the indicator or manual scroll), subsequent messages auto-scroll again.",
          "Add tests ensuring that the paused state is purely per-session (no persistence across reloads) and doesn't bleed into other chat instances, if any."
        ]
      },
      "devon": {
        "goal": "Implement auto-scroll pause/resume and UX indicator in ChatPanel.",
        "steps": [
          "Build on C1’s userWantsAutoScroll flag to gate the auto-scroll behavior in the messages watcher.",
          "Add reactive state for \"hasNewMessagesWhilePaused\" that toggles when new messages arrive while userWantsAutoScroll is false.",
          "Render a small pill or banner (e.g., \"New messages below\") in the ChatPanel when hasNewMessagesWhilePaused is true and wire it to scrollToBottom() + re-enable userWantsAutoScroll when clicked.",
          "Make sure this works for both streaming responses and one-shot responses, and that there are no race conditions between rapid incoming messages and user scrolling."
        ]
      }
    },
    "reason": "F2-T1-S2: Respect user scroll intent in chat."
  },
  {
    "task_id": "2-1",
    "title": "D1 – Implement 3-line clamp + expand for latest user message",
    "status": "pending",
    "workflow_stage": "orion_planning",
    "basic_info": {
      "goal": "Limit visible height of the latest user message to ~3 lines, expandable.",
      "area": "Chat Layout",
      "notes": "Add isExpanded flag per message and clamp user message block with Show more/Show less toggle."
    },
    "instruction": {
      "tara": {
        "goal": "Define expectations for clamping and expanding long user messages.",
        "tests": [
          "Create frontend tests that mount ChatPanel with a very long user message and assert that only ~3 lines are visible by default (use CSS classes like line-clamp or max-height-based assertions).",
          "Add a test that clicking \"Show more\" reveals the full message and toggles the control text to \"Show less\".",
          "Add a test that clicking \"Show less\" re-applies the clamp without breaking scroll position or selection.",
          "Verify that short messages (<= 3 lines) do not show the Show more/less controls at all."
        ]
      },
      "devon": {
        "goal": "Implement clamped + expandable layout for the latest user message in ChatPanel.",
        "steps": [
          "Extend message objects with an isExpanded flag, defaulting to false for new user messages.",
          "In the ChatPanel template, wrap user message text in a container that applies a 3-line clamp (Tailwind line-clamp utilities or custom CSS) when !isExpanded and full height when isExpanded.",
          "Render a Show more / Show less toggle only when the content exceeds the clamp height; this can be approximated or derived from message length.",
          "Ensure that expansion/collapse does not interfere with auto-scroll behavior (C-tasks) or with the streaming state of subsequent AI messages."
        ]
      }
    },
    "reason": "F2-T1-S2: Improve readability of long user prompts."
  },
  {
    "task_id": "2-1",
    "title": "D2 – Refine layout so new message is visually highlighted",
    "status": "pending",
    "workflow_stage": "orion_planning",
    "basic_info": {
      "goal": "Make the newest user message easy to locate while preserving scrollable history.",
      "area": "Chat Layout",
      "notes": "Ensure after send, the latest user message is visible with clamp applied; keep infinite scroll for history."
    },
    "instruction": {
      "tara": {
        "goal": "Clarify how the latest user message should be positioned and styled.",
        "tests": [
          "Add tests that after sending a new user message, the viewport scrolls just enough to fully reveal that message (within clamp) while keeping history accessible above.",
          "Add tests that verify a subtle visual highlight (e.g., background or border) is applied to the most recent user message and removed when a newer message is sent.",
          "Ensure that infinite scroll upwards (loading older messages) does not break the highlight behavior for the truly latest message.",
          "Confirm that the highlighted behavior works correctly for both short and clamped long messages."
        ]
      },
      "devon": {
        "goal": "Adjust ChatPanel layout and styling so new messages stand out without breaking scroll.",
        "steps": [
          "Introduce a way to identify the latest user message in the messages array (e.g., by index or a flag) and apply a distinct CSS class for visual emphasis (background/border).",
          "Ensure that after handleSendMessage runs, the panel scrolls such that the latest message is within view but does not unnecessarily overscroll past it.",
          "Verify that loading older messages at the top via infinite scroll does not change which message is flagged as \"latest\".",
          "Keep all structural changes minimal so they do not conflict with existing Tailwind styles or break tests for existing behaviors."
        ]
      }
    },
    "reason": "F2-T1-S2: Align new-message behavior with desired UX."
  },
  {
    "task_id": "2-1",
    "title": "E1 – Identify and reproduce silent error path in DatabaseTool.js",
    "status": "pending",
    "workflow_stage": "orion_planning",
    "basic_info": {
      "goal": "Find where DatabaseTool is swallowing errors instead of surfacing them.",
      "area": "DatabaseTool",
      "notes": "Run relevant Jest suites and inspect try/catch blocks that only log without rethrowing."
    },
    "instruction": {
      "tara": {
        "goal": "Make the silent error behavior explicit via tests.",
        "tests": [
          "In backend/src/_test_/database_tool_agent_adapter.spec.js and/or orion_db_surface_v1_1.spec.js, add tests that simulate DB failures (e.g., mock db.query to throw) and assert that the error surfaces through DatabaseToolAgentAdapter and up to the caller, not swallowed.",
          "Add a test that specifically demonstrates the current silent failure (if reproducible) so Devon has a clear red case to fix.",
          "Ensure tests assert both error messages and that no successful-looking payload is returned in error scenarios.",
          "Avoid tying tests to logging side effects; focus on throw vs. no-throw behavior and error propagation."
        ]
      },
      "devon": {
        "goal": "Locate and understand the silent error path before changing behavior.",
        "steps": [
          "Run the updated Jest suites to see where tests fail due to silent error behavior.",
          "Inspect backend/tools/DatabaseTool.js for try/catch blocks that log errors but do not rethrow, paying special attention to create_*/update_* methods and any generic query wrappers.",
          "Trace the execution path from the failing test through DatabaseToolAgentAdapter to DatabaseTool to identify the exact spot where an error is lost.",
          "Document the problematic path in comments or a short DEV note, including before/after behavior expectations, before modifying code in E2."
        ]
      }
    },
    "reason": "F2-T1-S2: Prepare to fix silent DB failures."
  },
  {
    "task_id": "2-1",
    "title": "E2 – Refactor DatabaseTool error handling to fail loudly",
    "status": "pending",
    "workflow_stage": "orion_planning",
    "basic_info": {
      "goal": "Ensure all critical DatabaseTool operations throw descriptive errors on failure.",
      "area": "DatabaseTool",
      "notes": "Tighten error handling on core methods; keep logging helpers non-fatal. Update tests accordingly."
    },
    "instruction": {
      "tara": {
        "goal": "Lock in the new error-handling contract.",
        "tests": [
          "Expand the E1 tests so that once Devon refactors, they assert that DatabaseTool methods throw errors with clear, namespaced messages (e.g., DatabaseTool.create_subtask failed: ...).",
          "Add tests ensuring that logging helpers (e.g., _addToActivityLog) are allowed to fail quietly without causing primary operations to throw, as long as this is intentional.",
          "Verify that API-level tests (e.g., api_chat_messages.spec.js) receive 5xx responses with the error details surfaced (where appropriate) rather than hanging or returning success."
        ]
      },
      "devon": {
        "goal": "Refactor DatabaseTool methods to align with the no-silent-failure policy.",
        "steps": [
          "Based on E1 findings, modify core DatabaseTool methods (create_feature, create_task, create_subtask, update_* methods, and generic query) to wrap internal errors in descriptive Error instances and rethrow them.",
          "Ensure that each thrown error includes enough context (method name, key arguments) to be actionable during debugging.",
          "Keep logging helpers and non-critical paths using console.error without rethrows, as long as the main operation has already succeeded and tests confirm this.",
          "Re-run the Jest suite to ensure all tests added by Tara now pass and that no new silent error paths have been introduced."
        ]
      }
    },
    "reason": "F2-T1-S2: Enforce no-silent-failure policy in DB layer."
  },
  {
    "task_id": "2-1",
    "title": "F1 – Implement remaining DatabaseToolAgentAdapter methods",
    "status": "pending",
    "workflow_stage": "orion_planning",
    "basic_info": {
      "goal": "Add adapters for 11 remaining DatabaseTool functions.",
      "area": "Tooling",
      "notes": "Follow oneTool.md pattern: validate args, resolve projectId, call positional DatabaseTool API, return result."
    },
    "instruction": {
      "tara": {
        "goal": "Define expectations for each adapter method’s argument mapping and error behavior.",
        "tests": [
          "In backend/src/_test_/database_tool_agent_adapter.spec.js, add unit tests per adapter method (list_subtasks_for_task, get_feature_overview, list_subtasks_by_status, search_subtasks_by_keyword, update_*_sections, create_*, safe_query).",
          "For each method, add a happy-path test that stubs the underlying DatabaseTool method and asserts it is called with the correct positional arguments derived from the args object.",
          "Add error-path tests that verify missing required fields (e.g., task_id, feature_id, status, keyword) produce clear, namespaced error messages.",
          "Ensure tests cover projectId resolution precedence: explicit project_id in args, then context.projectId, then default 'P1'."
        ]
      },
      "devon": {
        "goal": "Implement adapter methods that faithfully map args objects to DatabaseTool’s positional API.",
        "steps": [
          "Open backend/tools/DatabaseToolAgentAdapter.js and follow the existing pattern used by the working golden-path method (get_subtask_full_context).",
          "For each remaining DatabaseTool function, add a corresponding async method that validates args, extracts required/optional fields, resolves projectId, and calls the correct DatabaseTool method with positional arguments.",
          "Ensure no business logic is added in the adapter; it should remain a thin translation layer between tool-call JSON and DatabaseTool methods.",
          "Keep error messages explicit and consistent so they match Tara’s test expectations and surface clearly through Orion."
        ]
      }
    },
    "reason": "F2-T1-S2: Expand Orion DB tool coverage."
  },
  {
    "task_id": "2-1",
    "title": "F2 – Add tests for new DatabaseToolAgentAdapter methods",
    "status": "pending",
    "workflow_stage": "orion_planning",
    "basic_info": {
      "goal": "Cover happy/error paths for each new adapter method.",
      "area": "Tooling",
      "notes": "Extend database_tool_agent_adapter.spec.js to assert argument mapping and error messages."
    },
    "instruction": {
      "tara": {
        "goal": "Complete test coverage for all new adapter methods.",
        "tests": [
          "Ensure each adapter method has at least one happy-path and one error-path test, as outlined in F1.",
          "Add tests for edge cases such as null/undefined optional fields, extra unknown properties in args, and invalid value types.",
          "Verify that errors thrown by underlying DatabaseTool methods are propagated verbatim (or with a clear wrapper) and not replaced by generic messages.",
          "Confirm that adapter methods never mutate the args object passed in (pure translation only)."
        ]
      },
      "devon": {
        "goal": "Align adapter implementation with Tara’s expanded test suite.",
        "steps": [
          "Run the database_tool_agent_adapter.spec.js tests and fix any failing adapter methods by correcting argument order, validation, or error messages.",
          "Ensure that projectId resolution logic is centralized or consistent across methods to reduce duplication and bugs.",
          "Refactor adapter code for readability and maintainability once tests are green, without changing externally observed behavior.",
          "Double-check that no adapter bypasses DatabaseTool or accesses the DB directly, preserving layered architecture."
        ]
      }
    },
    "reason": "F2-T1-S2: Guardrail for new adapter layer."
  },
  {
    "task_id": "2-1",
    "title": "F3 – Verify FileSystemTool compatibility with single-args pattern",
    "status": "pending",
    "workflow_stage": "orion_planning",
    "basic_info": {
      "goal": "Confirm all FS tools accept a single args object and behave correctly.",
      "area": "Tooling",
      "notes": "Review FileSystemTool functions and add tests if needed (read_file, write_to_file, list_files, search_files)."
    },
    "instruction": {
      "tara": {
        "goal": "Specify behavior and contract for FileSystemTool methods when called from Orion.",
        "tests": [
          "Create or extend a backend spec for FileSystemTool (e.g., backend/src/_test_/filesystem_tool.spec.js) that calls each tool with a single args object (path, content, recursive, regex, file_pattern).",
          "Add tests ensuring that invalid args (missing path, invalid regex, unsupported patterns) produce clear, testable errors.",
          "Add tests confirming that list_files and search_files respect the ignore rules (if any) and do not traverse outside allowed directories.",
          "Ensure tests treat FileSystemTool as a pure tool layer (no DB assumptions, no business logic)."
        ]
      },
      "devon": {
        "goal": "Confirm and, if needed, adjust FileSystemTool to match the single-args tool contract.",
        "steps": [
          "Review backend/tools/FileSystemTool.js to ensure each exported tool function takes a single args object and accesses properties defensively (e.g., args.path).",
          "Align parameter names and defaults with what functionDefinitions.js and Orion’s tool-call schema expect.",
          "Fix any deviations found by Tara’s tests, such as functions that still expect positional arguments or fail silently on bad input.",
          "Keep FileSystemTool side effects and error messages clear and explicit, matching the same no-silent-failure philosophy used for DatabaseTool."
        ]
      }
    },
    "reason": "F2-T1-S2: Ensure FS tools match Orion’s tool-call contract."
  }
]
